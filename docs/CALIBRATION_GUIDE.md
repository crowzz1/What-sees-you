# STS3215 机械臂校准与控制指南

## 1. 核心理念：为什么要把中点设为 2048？

传统的舵机控制范围是 `0` 到 `4095`。如果你的机械臂运动范围恰好跨越了 `0/4096` 的边界（例如从 4000 转到 100），控制逻辑会变得非常复杂，容易出现“绕远路”甚至反向猛冲的情况。

**解决方案：**
使用 STS3215 的 **一键中点校准** 功能，将机械臂的**物理自然中立姿态**重新映射为编码器数值 **2048**。

**好处：**
- **避开边界**：工作区间变成了以 2048 为中心的连续区间（例如 1000~3000）。
- **逻辑简单**：不再需要处理跨零逻辑，简单的加减法即可控制。
- **物理直观**：2048 就是正中间，往大是顺时针，往小是逆时针（或反之，视安装而定）。

---

## 2. 校准流程 (Standard Procedure)

### 步骤 1：物理归零
1. 将电机断电（或软件失能）。
2. 用手将机械臂摆到你认为的 **“自然中立姿态”**（例如手臂自然前伸或垂直）。
3. 保持这个姿势不动。

### 步骤 2：一键设中点
1. 运行校准脚本（如 `calibrate_4motors.py`）。
2. 脚本向寄存器 **0x28 (40)** 写入数值 **128**。
3. **立即生效**，无需断电。此时该位置的读数变为 **2048**。

### 步骤 3：记录极限位置
1. **记录 Min（初始位置）**：
   - 用手将机械臂转到你希望的 **“收缩/初始/归位状态”**。
   - 记录此时的数值（记为 `min`）。
   - *注意：数值可能很大（如 3700），也可能很小，只管记录即可。*

2. **记录 Max（最大活动位置）**：
   - 用手将机械臂转到你希望的 **“最大伸展/活动极限”**。
   - 记录此时的数值（记为 `max`）。

### 步骤 4：生成配置文件
将记录的数据填入程序：

```python
MOTOR_CALIBRATION = {
    1: {'center': 2048, 'min': 3128, 'max': 1135, 'name': '基座'},
    2: {'center': 2048, 'min': 3715, 'max': 1509, 'name': '肩部'},
    # ...
}
```

- **min**: 初始位置 / 归位点
- **max**: 最大活动范围

---

## 3. 控制策略 (Control Strategy)

### ✅ 启动 (Startup)
1. **使能所有电机**。
2. **依次归中**：Motor 1 -> 2 -> 3 -> 4 依次移动到 **2048**。
3. *技巧：使用“小步慢走”算法，避免上电猛冲。*

### ✅ 追踪 (Tracking)
1. **基于 2048 的增量控制**：
   - 目标位置 = 2048 + Delta。
2. **平滑移动**：
   - 使用 `move_time`（如 200ms）配合较低的控制频率（如 20Hz）。
   - 只有当目标变化超过阈值时才发送指令。

### ✅ 关闭 (Shutdown)
**正确顺序：**
1. **全员归中**：所有电机先回到 **2048**（防止从极限位置直接归位导致姿态失控）。
2. **归位顺序**：
   - Motor 1 保持在中点。
   - Motor 4 回到 **初始位置 (`min`)**。
   - Motor 3 和 Motor 2 协同回到 **初始位置 (`min`)**（Motor 3 先动，Motor 2 延迟）。

---

## 4. 常见问题与解决

### Q1: 为什么我看 min 比 max 还大？
**A:** 这是正常的。STS3215 逆时针旋转数值增加。
- 如果你的“初始位置”是在逆时针极限，数值就会很大（如 3700）。
- 如果你的“最大活动位置”是在顺时针极限，数值就会很小（如 1500）。
- **关键是记住：min = 初始位置，max = 活动极限。**

### Q2: 为什么电机会“猛冲”？
**A:**
1. `move_time` 设为 0（全速）。
2. 目标位置距离当前位置太远。
3. **解决**：使用 `_move_slowly` 函数，将长距离拆分成小碎步，每步带 `move_time`。

### Q3: 真的不需要断电吗？
**A:** 不需要。
- 虽然有些文档说 Offset 需要断电，但 STS3215 的 **一键中点功能 (Reg 40 = 128)** 是 **立即生效** 的。

### Q4: 还能跨零吗？
**A:**
- 物理上：只要你的活动范围不超过 360度，设置中点为 2048 后，通常不会再碰到 0/4096 边界。
- 代码上：为了保险，建议保留最短路径逻辑 (`diff > 2048` 处理)，以防万一电机被意外转到了边界附近。

---

## 5. 关键代码片段

### 一键中点校准
```python
def set_middle_position(self, servo_id):
    # 地址 40 (0x28) 写入 128
    self._send_packet(servo_id, self.INST_WRITE, [0x28, 128])
    time.sleep(0.5)
```

### 小步慢走 (Smooth Move)
```python
def _move_slowly(self, motor_id, target, step_size=80, step_time=300):
    # 计算差值
    diff = target - current
    # 分步执行
    steps = int(abs(diff) / step_size)
    for i in range(steps):
        # 发送中间点，每次只移动 step_size
        driver.set_position(..., move_time=step_time)
        time.sleep(0.08) # 快速发送
```


